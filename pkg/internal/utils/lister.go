package utils

import (
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/tools/cache"
	"k8s.io/klog/v2"
)

// ResourceIndexer wraps an indexer, resource, and optional namespace for a given type.
// This is intended for use by listers (generated by lister-gen) only.
type ResourceIndexer[T runtime.Object] struct {
	indexer   cache.Indexer
	resource  schema.GroupResource
	namespace string // empty for non-namespaced types
}

// New returns a new instance of a lister (resource indexer) wrapping the given indexer and resource for the specified type.
// This is intended for use by listers (generated by lister-gen) only.
func NewResourceIndexer[T runtime.Object](indexer cache.Indexer, resource schema.GroupResource, namespace string) ResourceIndexer[T] {
	return ResourceIndexer[T]{indexer: indexer, resource: resource, namespace: namespace}
}

// List lists all resources in the indexer matching the given selector.
func (l ResourceIndexer[T]) List(labelSelector labels.Selector, annotationSelector labels.Selector) (ret []T, err error) {
	// ListAllByNamespace reverts to ListAll on empty namespaces
	err = ListAllByNamespace(l.indexer, l.namespace, labelSelector, annotationSelector, func(m interface{}) {
		ret = append(ret, m.(T))
	})
	return ret, err
}

// Get retrieves the resource from the index for a given name.
func (l ResourceIndexer[T]) Get(name string) (T, error) {
	var key string
	if l.namespace == "" {
		key = name
	} else {
		key = l.namespace + "/" + name
	}
	obj, exists, err := l.indexer.GetByKey(key)
	if err != nil {
		return *new(T), err
	}
	if !exists {
		return *new(T), errors.NewNotFound(l.resource, name)
	}
	return obj.(T), nil
}

// ListAll lists items in the store matching the given selector, calling appendFn on each one.
func ListAll(store cache.Store, labelSelector labels.Selector, annotationSelector labels.Selector, appendFn cache.AppendFunc) error {
	selectAll := labelSelector.Empty() && annotationSelector.Empty()
	for _, m := range store.List() {
		if selectAll {
			// Avoid computing labels of the objects to speed up common flows
			// of listing all objects.
			appendFn(m)
			continue
		}
		metadata, err := meta.Accessor(m)
		if err != nil {
			return err
		}
		if labelSelector.Matches(labels.Set(metadata.GetLabels())) && annotationSelector.Matches(labels.Set(metadata.GetAnnotations())) {
			appendFn(m)
		}
	}
	return nil
}

// ListAllByNamespace lists items in the given namespace in the store matching the given selector,
// calling appendFn on each one.
// If a blank namespace (NamespaceAll) is specified, this delegates to ListAll().
func ListAllByNamespace(indexer cache.Indexer, namespace string, labelSelector labels.Selector, annotationSelector labels.Selector, appendFn cache.AppendFunc) error {
	if namespace == metav1.NamespaceAll {
		return ListAll(indexer, labelSelector, annotationSelector, appendFn)
	}

	items, err := indexer.Index(cache.NamespaceIndex, &metav1.ObjectMeta{Namespace: namespace})
	if err != nil {
		// Ignore error; do slow search without index.
		//
		// ListAllByNamespace is called by generated code
		// (k8s.io/client-go/listers) and probably not worth converting
		// to contextual logging, which would require changing all of
		// those APIs.
		klog.TODO().Info("Warning: can not retrieve list of objects using index", "err", err)
		for _, m := range indexer.List() {
			metadata, err := meta.Accessor(m)
			if err != nil {
				return err
			}
			if metadata.GetNamespace() == namespace && labelSelector.Matches(labels.Set(metadata.GetLabels())) && annotationSelector.Matches(labels.Set(metadata.GetAnnotations())) {
				appendFn(m)
			}

		}
		return nil
	}

	selectAll := labelSelector.Empty() && annotationSelector.Empty()
	for _, m := range items {
		if selectAll {
			// Avoid computing labels of the objects to speed up common flows
			// of listing all objects.
			appendFn(m)
			continue
		}
		metadata, err := meta.Accessor(m)
		if err != nil {
			return err
		}
		if labelSelector.Matches(labels.Set(metadata.GetLabels())) && annotationSelector.Matches(labels.Set(metadata.GetAnnotations())) {
			appendFn(m)
		}

	}

	return nil
}
